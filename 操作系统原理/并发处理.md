# 并发处理
## 并发活动-进程的引入
#### 顺序执行

一个计算由若干个操作组成，而这些操作必须按照某种先后次序来执行，以保证操作的结果是正确的，则这类计算过程是程序的顺序执行过程。

- 顺序性:每个操作必须在下一个操作开始执行前结束。
- 封闭性：程序一旦开始执行，其结果不受外界因素的影响。
- 可再现性程序执行的结果与它的执行速度无关（与时间无关），只与初始条件有关。

#### 程序的并发执行

若干个程序段同时在系统中运行，这些程序段的执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序断是并发执行的。用以下语句表示。

```
cobegin
	S1;S2;S3;
coend
```

#### 与时间有关的错误

程序并发执行时若共享了公共变量，则一个程序的执行会改变另一个程序的变量，因此其输出结果将受外界的影响而失去封闭性，其执行结果将与并发程序执行的相对速度有关，即给定相同的初始条件，也可能会得到不同的结果，此为与时间有关的错误。为了保证得到唯一的结果，需要实现并发程序执行时的互斥和同步。

#### 并发程序的特点

- 失去程序的封闭性
- 程序与计算不再一一对应
- 程序并发执行相互制约

## 进程概念

### 进程的定义
进程是处理机活动的一个抽象概念。是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。

进程和程序是既有联系又有区别的两个概念：
- 程序是指令的有序集合，其本身没有任何运行的含义，它是一个静态概念。而进程是程序在处理机上的一次执行过程，它是一个动态概念。程序作为一种软件资料长期保存，而进程则是有一定的生命周期，可以动态的产生和消亡。
- 进程是一个能独立运行的单位，能与其他进程并行的活动。
- 进程是竞争计算机系统有限资源的基本单位，也是进行处理机调度的基本单位。

### 进程的类型

有些进程起着资源管理和控制的作用，称为系统进程；而另一些是为用户算题任务而建立的进程称为用户进程。

- 系统进程被分配一个初始的资源集合，这些资源可为它所独占，也可以最高优先级的资格优先使用。用户进程通过系统服务请求的手段竞争系统资源。
- 用户进程不能做直接I/O操作，而系统进程可以做显示的、直接的I/O操作。
- 系统进程在管态下活动，而用户进程在用户态下活动。

### 进程的状态
#### 进程的基本状态

- 就绪状态：当进程获得了除CPU之外所有的资源，它已经准备就绪，一旦得到了CPU控制权，就可以立即运行，该进程所处的状态为就绪状态。
- 运行状态：当进程由调度/分派模块分派后，得到中央处理机控制权，它的程序正在运行，该进程所处的状态为运行状态。
- 等待状态：若一进程正在等待某一事件发生而暂时停止执行，即使给它CPU控制权，它也无法执行，则称该进程处于等待状态，又称为**阻塞状态**。

#### 进程状态变迁图

进程并非固定处于某个状态，它将随着自身的推进和外界条件的变化而发生变化。
![](https://github.com/imgaojp/note/raw/master/images/进程基本变迁.JPG)

#### 进程的描述-进程控制块

进程是程序一次执行过程。程序是完成该进程活动的算法描述。为了刻画一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块，称为进程控制块（PCB）或者进程描述器（process descriptor）。当系统创建一个进程时，必须为它设置一个pcb，然后根据pcb信息对进程实施控制管理。进程任务完成时，系统撤销它的pcb，进程也随之消亡。

pcb的结构如下：

>name：唯一的进程标识符。


>status：进程的当前状态。


>next：当前队列指针。


>all_q_next：总链指针。


>start_addr：程序开始地址。


>priority：进程的优先级。


>CPUstatus：CPU现场保护区。


>communication_information：通信信息。


>process_family：家族联系。


>own_resource：占有资源清单。

### 线程概念及特点
#### 什么是线程

线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多个执行路径，即线程。在一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。

- 线程是进程中的一条路径
- 它有自己私用的堆栈和处理机执行环境
- 它共享分配给父进程的主存
- 它是单个进程所创建的许多个同时存在的线程中的一个

**进程和线程既有联系又有区别，对于进程的组成可以高度概括为以下几个方面：**

- 一个可执行程序，它定义了初始代码和数据
- 一个私用地址空间，它是进程可以使用的一组虚拟主存地址
- 进程执行时所需的系统资源（文件、信号灯、通信端口等），是由操作系统分配给进程的
- 若系统支持线程运行，那么每个进程至少有一个执行线程

进程是任务调度的单位，也是系统资源分配的单位；而线程是进程中的一条执行路径，当系统支持多线程时，线程是任务调度的单位，但不是系统资源分配单位。线程完全继承父进程占有的资源，当它活动时，具有自己的运行现场。
#### 线程的特点与状态

- 线程的特点：相对进程而言，线程的创建与管理的开销要小得多。因为线程可以共享父进程的所有程序和全局数据，创建一个新的线程只涉及最小量的主存分配，也意味着一个进程创建的多个线程可以共享地址区域和数据。在进程内创建多线程可以提高系统的并行处理能力。
- 线程的状态变迁：如果一个系统支持线程的创建与线程的活动，那么处理机调度的最小单位是线程而不是进程。线程是争夺CPU的单位。
	- 创建。建立一个新线程，新生的线程将处于新建状态。此时它已经具有了相应地主存空间和其他资源，并已被初始化。
	- 就绪。线程处于线程就绪队列中，并等待被调度。此时已经具备了运行的条件，一旦分配到CPU时间，就可以立即去运行。
	- 运行。一个线程正占用CPU，执行它的程序。
	- 等待。一个正在执行的线程，如果发生某些事件，如被挂起或需要执行费时的输入/输出操作时，将让出CPU，暂时中止自己的执行，进入等待状态。等待另一个线程唤醒它。
	- 终止。一个线程已经退出，但该信息还没被其它线程所收集。
- 用户线程和内核线程。
	- 用户线程是在内核的支持下，在用户通过线程库实现的。线程库提供对线程创建、调度和管理等方面的支持。由于内核并不知道用户级的线程，所以用户线程的创建和调度是在用户空间内进行的，不需要内核干预。
	- 内核线程由操作系统直接支持。内核在其空间内执行线程创建、调度和管理。由于线程的管理是由操作系统完成的，所以内核线程的创建和管理比在用户级创建和管理用户线程要慢；但正是由于内核管理线程，当一个线程执行等待的系统调用时，内核 能调度应用程序内的另一个线程去运行。
![](https://github.com/Imgaojp/Note/raw/master/images/线程的生命周期.JPG)

## 进程控制
### 进程控制的概念

进程控制的职责是对系统中的全部进程实施有效的管理，它是处理机管理功能的一部分，当系统允许多进程并发执行时，为了实现共享、协调并发进程的关系，处理机管理就必须提供对进程实行有效控制的功能。操作系统的核心具有创建、撤销进程和实施进程间同步、通信等功能。

原语是一种特殊的系统调用，它可以完成一个特定的功能，一般为外层软件调用，原语执行时具有原子性。用于进程控制的原语有：创建原语、撤消原语、阻塞原语、唤醒原语等。
### 进程创建
无论是系统还是用户创建进程都必须调用创建原语来实现。

```
create(name,priority,start_addr)
算法 create
输入：新进程的符号名，优先级，开始执行地址
输出：新创建进程的内部标识符pid
{
	在总链队列上查找有无同名的进程
	if（有同名进程）
		return错误码
	从pcb资源池申请一个空闲的pcb结构
	if（无pcb结构）
		return错误码
	用入口参数设置pcb结构
	置进程为“就绪”状态
	将新进程的pcb插入就绪队列
	将新进程的pcb插入总链队列
	return 新进程的pid
}
```

### 进程撤销
一个进程由进程创建原语创建，当其完成了其任务通过进程撤销原语终止自己。

```
算法 kill
输入：无
输出：无
{
	由运行指针得当前进程的pid
	释放本进程所占用的资源给父进程
	该进程从总链队列中摘除
	释放此pcb结构
	转进程调度、
}
```

### 进程阻塞
当进程需要等待某一事件完成时，它可以调用阻塞原语把自己挂起。一旦被挂起，只能由另一个进程唤醒。

阻塞命令的功能是停止调用进程的执行，将CPU现场保留到该进程的pcb现场保护区；然后改变其状态为“等待”。并插入到等待chan的等待队列上；最后使控制转向进程调度，以选择下一个进程。

```
算法 susp
输入：chan等待的事件（阻塞原因）
输出：无
{
	保护现行进程的CPU现场到pcb结构中
	置该进程为“阻塞”态
	将该进程pcb插入到等待chan的等待队列
	转进程调度
}
```

### 进程唤醒
唤醒原语的功能是当进程等待的事情发生时，唤醒等待该事件的进程。
```
算法 wakeup
输入：chan等待的事件
输出：无
{
	找到该阻塞原因的队列指针
	for（等待该事件的进程）{
		将该进程移除此等待队列
		置进程状态为“就绪”
		将进程pcb插入就绪队列
	}
}
```
### 进程延迟
#### 通用延迟过程
当某进程需要延迟一段时间再执行时，它发出delay命令，由操作系统的延迟过程完成此功能。
```
算法 delay
输入：seconds
输出：无
{
	保护调用进程的CPU现场
	clock_ticks=seconds*（clock_rate）
	封锁延迟队列
	以clock_ticks值检索延迟队列
	找到合适的位置插入
	解锁延迟队列
	置该进程为延迟状态
	转进程调度
}
```
#### 延迟唤醒进程
当某一进程延迟时间到时，由延迟唤醒进程把它唤醒。延迟唤醒进程是一个系统进程，它在系统初始化时被创建，之后它连续执行直到系统关闭。

不论是延迟唤醒进程还是通用延迟过程都要使用延迟队列。为了保证队列的完整性，在进行队列操作时必须封锁延迟队列，操作完毕后再解锁。
## 进程的相互制约关系
### 进程竞争与合作
在操作系统环境中，活动的大量的并发进程有着相互制约关系。这种制约关系分为两种：一种是由于竞争系统资源而引起的间接相互制约关系；另一种是由于进程之间存在共享数据而引起的直接相互制约关系。
#### 竞争系统资源
凡使用共享资源的进程，先向系统提出申请，然后由操作系统的资源管理程序根据资源情况，按一定的策略来实施分配。
#### 进程协作
当进程之间存在共享数据时，将引起直接的相互制约关系。例如，并发进程之间共享了某些数据、变量、队列等，为了使个进程不致因争夺共享数据而发生混乱，保证数据的完整性，需要正确的处理进程协作的问题（同步机制）。为什么出现需要协作的问题？

- 信息共享。操作系统必须提供支持允许共享资源的并发访问。由于对信息的共享，这些进程是合作进程。
- 并行处理。由于并行子任务是为了完成一个整体任务而并发执行的，它们之间一定有直接的相互制约关系，这些进程称为合作进程。

进程之间的直接相互制约关系必然导致进程之间需按一定的方式进程信息传递，这就是进程通信的关系。进程通信关系又可细分为：进程互斥、进程同步和进程的直接通信。
### 进程互斥的概念
进程之间的直接相互制约是通过进程通信来实现的，它们之间需要交换信息以便达到协调的目的，也就是需要同步。进程同步广义的定义是指对于进程操作的时间顺序所加的某种限制。如“操作A和操作B不能在同一时刻执行”，这种同步规则称为互斥。
#### 临界资源
通常把一次仅允许一个进程使用的资源称为临界资源。包括许多物理设备，如输入级、打印机等和一些软件资源，如变量、数据、队列等。他们虽可为若干进程所共享，但是一次只能为一个进程所使用。
#### 临界区
在每个进程中，访问临界资源的那段程序能够从概念上分离出来，称为临界区或临界段。

- 当有若干进程欲进入它的临界区时，应在有限时间内使进程进入临界区。它们不应相互阻塞而使彼此都不能进入临界区。
- 每次至多有一个进程处于临界区。
- 进程在临界区内仅逗留有限的时间。

#### 互斥
通常把允许若干进程均能访问和修改的存储单元称为公共变量。共享的各方不能同时读写同一数据区，只有当一方读、写完毕后，另一方才能读、写。进程之间的这种相互制约关系称为互斥。
### 进程同步的概念
互斥解决了并发进程对临界区的使用问题。这种基于临界区控制的交互作用是比较简单的，只要每个进程对临界区的执行时间互斥，每个进程就可以忽略其它进程的存在和作用。另外还要解决异步环境下的进程同步问题。异步环境指：相互合作的一组并发进程，其中每个进程都已各自独立的、不可预知的速度向前推进；但它们又需要密切合作，以实现一个共同的任务，即彼此“知道”相互的存在和作用。

所谓同步就是并发进程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息就称为进程同步。
## 同步机构
### 锁和上锁、开锁操作
在锁这一同步机构中，对应于每一共享数据块或设备都有一个单独的锁位。常用锁位值为“0”表示资源可用，而“1”表示资源已被占用。这样进程使用某一共享资源前必须完成以下动作：

- 检测原来的值（是0还是1）
- 如果原来的值是0，将锁位置为1
- 如果原来的值是1，则返回第一步再考察
- 当进程使用完资源后，将锁位置为0，称为开锁操作

```
算法 lock
输入：锁变量w
输出：无
{
	test：if(w==1)
			goto test
			else w==1
}
```

```
算法 unlock
输入：锁变量
输出：无
{
	w==0
}
```

上述简单的上锁原语中，goto使得lock（w）原语的进程占用处理机而等待进入互斥断。修改后的如下：

```
算法 lock1
输入：锁变量w
输出：无
{
	while（w==1）
	{
		保护现行进程的CPU现场
		将现行进程的pcb插入w的等待队列
		置该进程为“等待”状态
		转进程调度
	}
	w=1
}
```

```
算法 unlock1
输入：锁变量w
输出：无
{
	if（w等待队列不为空）{
		移出等待队列首元素
		将该进程的pcb插入就绪状态
		置该进程为“就绪”状态
	}
	w=0
}
```

### 信号灯和P、V操作

- 信号灯

信号灯是一个确定的二元组（s，q），s是一个具有非负初值的整型变量（可用资源的数量），q是一个初始状态为空的队列。整型变量s代表资源的实体或并发进程的状态，操作系统利用信号灯的状态对并发进程和共享资源进行管理。

- P、V操作

信号灯的数值仅能由P、V操作加以改变。对信号灯的P操作记为p（s）。p（s）是一个不可分割的原语操作，即取信号灯值减1，若相减结果为负，则调用p（s）的进程被阻，并插入到该信号灯的等待队列中否则可以继续执行。P操作主要动作如下：

- s值减1
- 若相减结果大于或等于0，则进程继续执行
- 若相减结果小于0，该进程被封锁，并将它插入到该信号灯的等待队列中，然后转入进程调度程序

```
算法 p
输入：变量s
输出：无
{
	s--
	if（s<0）
	{	保留调用进程CPU现场
		将该进程的pcb插入s的等待队列
		置该进程为“等待”状态
		转进程调度
	}
}
```

对信号灯的V操作记为v（s）。v（s）是一个不可分割的原语操作，取信号灯值加1，若相加结果大于0，进程继续执行，否则要帮助唤醒在信号灯等待队列上的一个进程。V操作的主要动作如下：

- s值加1
- 若相加结果大于0，进程继续执行
- 若相加结果小于或等于0，则从该信号灯的等待队列中移出一个进程，解除它的等待状态，然后返回本进程继续执行。

```
算法 v
输入：变量s
输出：无
{
	s++
	if（s<=0）
	{	移出s等待队列首元素
		将该进程的pcb插入就绪队列
		置该进程为“就绪”状态
	}
}
```

## 进程互斥与同步的实现
### 使用上锁原语和开锁原语实现进程互斥
使用上锁原语和开锁原语可以解决并发进程的互斥问题。任何进入临界区的进程，必须先执行上锁原语。若上锁原语顺利通过，则进程可以进入临界区；在完成对临界资源的访问后再执行开锁原语，以释放该临界资源。

```C
程序 task1
main(){
	int w=0;
	cobegin
		ppa();
		ppb();
	coend
}

ppa(){
	...
	lock(w);
	csa();
	unlock(w);
}

ppb(){
	...
	lock(w);
	csb();
	unlock(w);
}
```

### 使用信号灯实现进程互斥
使用信号灯能方便地解决临界区问题。

```C
程序 task1
main(){
	int mutex=0;
	cobegin
		ppa();
		ppb();
	coend
}

ppa(){
	...
	p(mutex);
	csa();
	v(mutex);
}

ppb(){
	...
	p(mutex);
	csa();
	v(mutex);
}
```

### 进程同步的实现
