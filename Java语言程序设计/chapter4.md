# Java面向对象特性
## 概述
### Java的OOP特性
- 封装（encapsulation）


将对象的数据与操作数据的方法相结合，通过方法将对象的数据与实现细节保护起来，就称为封装。外界只能通过对象的方法访问对象，因此封装同时也实现了对象的数据隐藏。<br>
Java语言中，通过类这样的语言机制实现了数据的封装与隐藏。
- 继承（inheritance）

当一个类是另一个类的特例时，这两个类之间有父子类关系。子类继承了父类的状态（变量）和行为（方法），子类可以重复使用父类中的这部分代码。<br>
Java中只支持类之间的单继承，多重继承要通过接口实现。
- 多态（polymorphism）


多态的含义可以表达为“对外一个接口，内部多种实现”。Java语言支持两种形式的多态：运行时多态和编译时多态。通过方法的重载（overloading）实现编译时多态，而通过类之间的继承性。方法重写以及晚联编技术实现运行时多态。<br>
多态使程序具有良好的可拓展性，并使程序易于编写维护、易于理解。

###Java中类和对象基本概念
类和对象是Java程序的基本组成要素。类描述了同一类对象都具有的数据和行为。Java语言中的类将这些数据和行为进行封装，形成了一种复合数据类型。创建一个新类就是创建了一种新的数据类型。在程序中类只定义一次，而用new运算符可以实例化用一个类的一个或多个对象。类定义和描述了一类对象的共同特征。
##类的定义
###类的基本结构
类有两种基本成分：变量和方法，称为成员变量和成员方法。类的成员变量可以使基本类型的数据或数组，也可以是一个类的实例。类的方法用于处理该类的数据。方法与其他语言中的函数的区别在于：(1)方法只能是类的成员，只能在类中定义。(2)调用一个类的成员方法，实际上是进行对象之间或用户与对象之间的消息传递。
Java类定义的基本语法：
```Java
<modifiers>class<class_name>{
	[<attribute_declarations>]
	[<constructor_declarations>]
	[<methods_declarations>]
}
```
Java类的定义可以分为两部分：类声明和类体。类体部分包括类成员变量的声明、构造方法和成员方法的声明与定义。
- 类的声明

类定义中的类声明部分主要是声明了该类的名字以及类的其它属性。
```
[public][abstarct|final]class ClassName[extends SuperClassName][implements InterfaceNameList]{...}
```
- 类体

出现在类声明后的大括号`{}`中的是类体。类体提供了这个类的对象在生命周期中需要的所有代码：构造和初始化新对象的构造方法，表示类及其对象状态的变量，实现类及其对象行为的方法，并且在极少数的情况下还可以有用来进行对象清除的finalize()方法。
- 类的封装与信息隐藏

Java中通过类实现封装与信息隐藏。具体是通过对类成员限定访问权限实现的。Java中用于类成员的访问权限有4种，分别用3中权限定义符——public,protected,private以及默认权限来定义。封装的同时最大限度的隐藏了对象内部细节，使得对象在于外界交互提供服务的同时，能够保证自身数据的完整性与一致性。

### 成员变量
当一个变量的声明出现在类体中并不属于任何一个方法，则该变量为所属类的成员变量。类成员变量的基本声明和一般变量声明一样，必须包括类型与变量名，但增加了许多可选的修饰选项。成员变量完整的声明格式如下：
```
[public|protected|private][static][final][transient][volatile] type varibleName;
```
public、protected、private|该对象成员变量的访问权限
---|---
static|限制该成员变量为类变量，没有static修饰的成员变量为实例变量
final|声明一个常量，final修饰的常量，程序中不能修改它的值，且命名应该用由下划线分开的大写的词表示
transient|用来声明一个暂时性变量。默认情况下，类中所有变量都是对象永久状态的一部分，当对象被保存到外存时，这些变量必须同时被保存。用transient限定的变量则指示JVM该变量不属于对象的永久状态，从而不能被永久存储。
volatile|volatile修饰的变量，在被多个并发线程共享时，系统将采取更优化的控制方法提高线程并发执行的效率。
### 成员方法
- 成员方法的定义
	- 方法的声明完整格式如下：
	```
	[<acesslevel>][static][final|abstract][native][synchronized]<return_type><name>([<argument_list>])[throws <exception_list>]{
		<block>
	}
	```
	- 方法体
	
	方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java语句。
	方法体中可以声明该方法中所用到的局部变量，它的作用域只在该方法内部，当方法返回时，局部变量也不再存在。如果局部变量名字和类成员变量的名字相同，则类的成员被隐藏，如果要将该类成员变量显露出来，则需在该变量前加上修饰符"this"。
- 方法调用中的参数传递方式

Java中方法调用的参数传递是传值，即调用方法不会改变调用程序中作为方法参数的变量的值。但是当方法的参数类型是对象或者数组等引用类型时，在方法调用中传递给该参数的仍然是调用程序中对应变量的值，即对某个对象或者数组的引用。但如果在方法中对该参数指向的对象进行修改，则这种修改将是永久的，即当从方法中退出时，对象的修改将被保留下来，在调用程序中可以看到这种改变。因此，在方法中可能改变引用类型所指向的对象的内容，但是对象的引用不会改变。
- 可变参数列表*Varargs*

使用可变参数表，可以使方法具有数目不定的多个参数。可变参数的定义格式一般为：
```Java
int...nums	//类型...参数名
```
使用可变参数列表需要注意一下问题：

1. 可变参数只能作为方法参数列表中的最后一个参数
2. 如果要调用的API中具有可变参数列表的方法，则尽量使用，使程序易读。如果要编写API则尽量少用，只在好处明显时使用。一般情况下，不要重载带有可变参数列表的方法，否则会使其他人很难确定具体被调用的重载方法。

### 方法重载
Java语言提供了方法重载（overloading）机制。方法的重载是允许在一个类的定义中，多个方法使用相同的方法名。
```Java
public void println(int i){...}
public void println(float f){...}
public void println(String str){...}
```
重载是指在同一个类中一个方法名被用来定义多个方法。方法重载是面向对象语言多态性的一种形式，它实现了编译时多态。即由编译器在编译时确定具体调用哪个被重载的方法。<br>
重载方法的名称都是相同的，但是在方法的声明中一定要有彼此不相同的成分，以使编译器能够区分这些方法。因此Java中规定重载的方法必须遵循以下原则：
- 方法的参数表必须不相同，包括参数的类型或个数，以此区分不同方法体。
- 方法返回类型、修饰符可以相同也可不同。

### this
this是Java使用的一个具有特定意义的引用，它指向当前对象本身。
### 构造方法
Java中所有的类都有构造方法，用来进行该类对象的初始化。构造方法也有名称、参数和方法体以及访问权限的限制。
- 构造方法的定义格式


```Java
[public|protected|private]<class_name>([<argument_list>]){
	[<statements>]
}
```


构造方法的定义十分特殊，其特点如下：

1. 构造方法的名称必须与类名相同。
2. 构造方法不能有返回值。
3. 用户不能直接调用构造方法，必须通过*new*关键字自动调用它。


- 默认的构造方法

在类的定义中可以不定义构造方法，而其他类仍然可以通过*new XXX()*来实例化*XXX*类的实例对象。因为Java在编译时给没有定义构造方法的类自动加入一个特殊的构造方法，这个方法不带参数且方法体为空，称之为类默认的构造方法。<br>
**注意：一旦在类中定义了构造方法，则默认的构造方法将不再被加到类的定义中。此时，如果程序中使用默认的构造方法将出现编译错误。为了避免此类错误，如果类中定义了构造方法，通常也将加入不带参数的构造方法。**
- 重载构造方法


构造方法可以重载，即定义多个构造方法，其参数表不同。重载构造方法的目的是使类对象具有不同的初始值，为类对象的初始化提供方便。

### 访问控制
- 访问控制概述

Java中，可以在类的定义中使用权限修饰符来保护类的变量和方法。Java支持如下四种不同的访问权限。

1. 私有的——以private修饰符指定：没有其他类可以实例化该类。此时这个类中可能包含一个具有public权限的方法（factory方法），只有这些方法可以构造该类的对象并将其返回。
2. 受保护的——以protected修饰符指定：只有这个类的子类以及与该类在同一个包中的类可以创建这个类的实例对象。
3. 公开的——以public修饰符指定：任何类都可以创建这个类的实例对象。
4. 默认的，也称为default或package——不适用任何修饰符：只有与该类在同一个包中的类可以创建这个类的实例对象。


对于类的成员变量和方法可以定义上述4种访问级别：public，protected，default，private，对于类（内部类）可以有public或default两种。
- private

类中带有*private*的成员只能被这个类自身访问。*private*对访问权限限制最大。一般把那些不想让外界访问的数据和方法声明为私有的，这有利于数据的安全并保证数据的一致性，也符合程序设计中隐藏内部信息处理细节的原则。<br>
对于构造方法也可以限定它为*private*。如果一个类的构造方法声明为*private*，则其它类不能生成该类的实例对象。<br>
**注意：同一个类的不同对象之间可以访问对方的*private*成员变量和方法。因为访问控制是在类的级别上的，不是在对象的级别上。**


```Java
class Alpha{
	private int iamprivate;
	public Alpha(int i){
		this.iamprivate = i;
	}
	boolean isEqualTo(Alpha anotherAlpha){
		if(this.iamprivate == anotherAlpha.iamprivate)	//访问另一个Alpha对象的私有变量
			return true;
		else
			return false;
	}
}
public class Test{
	public static void main(String args[]){
		Alpha aa = new Alpha(10);
		Alpha bb = new Alpha(22);
		if(aa.isEqualTo(bb)){	//aa可以访问另一个类的私有对象，再与自身私有变量进行对比
			System.out.println("equal");
		}else
			System.out.println("not equal");
	}
}
```
- default

不加任何访问权限限定的成员采用的默认访问权限，称为default或者package。default权限意味着可以被这个类本身和同一个包中的类访问。在其他包中定义的类，即使是这个类的子类，也不能直接访问这些成员。对于构造方法，如果不加任何访问权限也是default访问权限，则除这个类本身和同一个包中的类之外，其他类不能生成该类的实例。
- protected

类的定义中带有protected的成员可以被这个类本身、它的子类（与该类在同一个包或者不在）以及同一个包中的其它所有类访问。当同一个包中的类或子类都可以访问类的成员，而无关的类不能访问这些成员时，可将他们的访问权限设定为protected。
- public

public是最简单的访问控制修饰符。带有public的成员可以被所有的类访问，任何包中的任何类都可以直接访问public变量和方法。对于构造方法，如果访问权限限定为public，则在所有类中都可以生成该类的实例。<br>
一般把外界需要直接访问的类成员，很多情况下是方法，说明为public访问权限，用来作为外界与类交换信息的接口。

## 内部类
### 什么是内部类
内部类是在一个类的声明里声明的类，也成为嵌套类。内部类和包容它的类可以形成有机的整体。
```Java
class A{
	...
	class B{...}
	...
}
```
类B在类A中定义，所以B称为内部类，类A称为B的包容类或者外包类。
### 内部类的使用
- 内部类作为外包类的一个成员使用

内部类可以作为外包类的一个成员使用，可以访问外包类的所有成员，包括带有static的静态成员变量和方法，以及private私有成员。<br>
JVM在内部类实现中，在内部类对象中保存了一个对其外包类对象的引用。内部类可以通过该引用找到外包类的对象，进而访问外包类的成员，采用的格式是：外包类名.this.变量名。
- 在外包类的语句块中定义内部类

内部类可以在一个方法体的语句块中定义。这时内部类可以访问语句块中的局部变量，但只限于在该语句块运行期内，当该方法结束后，内部类对象将不能访问所在语句块中的局部变量。但因为final变量在方法运行结束后仍然存在，所以内部类对带有final的局部变量的访问不受限制。


另外，这样的内部类只能用于在定义它的语句块中创建内部类的对象，而且内部类的类名也不能出现在定义它的语句块之外。

- 在外包类以外的其他类中访问内部类

Java中，内部类的访问权限与普通类和接口不同，可以定义为public，protected，default或private，而普通类只能定义为public或者default两种。对于可以在外包类之外访问的内部类，引用内部类名时必须使用完整的标识：外包类名.内部类名，并且在创建内部类对象时，必须与外部类的对象相关。例如，类B是类A的内部类，则在其他类中要以下列格式访问类B：
```
A a = new A();
A.B b = a.new B();
```

### 内部类的特性
+ 内部类的类名只用于定义它的类或语句块之内，在外部引用它时必须给出带有外包类名的完整名称，并且内部类的名字不许与外包类的名字相同。
+ 内部类可以访问外包类的静态（static）或实例成员变量。
+ 内部类可以在成员方法中定义，该成员方法的局部变量及参数必须是final的才能被该内部类使用。
+ 内部类可以是抽象类或者接口。如果是接口，则可以由其它内部类实现。
+ 内部类可以使用public，protected，default，private这4种访问权限控制。
+ 内部类可以被声明为static（普通类是不可以的），这样内部类变成顶层类，相当于把它放在外面，不再是嵌套的内部类，并且它的对象中将不包含指向外包类对象的指针，所以不能再引用外包类对象。
+ 只有顶层类可以声明static成员。如果内部类需要定义static成员，则该内部类必须声明为static，否则，一般内部类的成员不能被声明为static。

## 对象的生命周期
对象的声明周期包括了对象的创建、对象的使用和对象回收3个阶段。
### 对象的创建
- 对象创建的步骤<br>
类是对象的模板，Java依据一个类创建一个对象。创建一个对象包括两个步骤：
	- 声明对象变量
	- 对象的实例化
- 创建与初始化对象的过程

### 对象的使用
- 引用对象的变量
- 调用对象的方法

### 对象的清除
- 垃圾收集器
- 对象的最终化（finalization）处理

## 类的继承与多态
### 类的继承
- 子类及其定义
- 单继承
- super关键字
- 子类对象的创建与实例化过程

### 方法的重写
- 子类中父类成员的隐藏
- 方法重写
- 方法重写遵守的规则

### 运行时多态
- 上溯造型（upcasting）
- 什么时候运行时多态
- 运行时多态的实现机理
- 多态的意义

### 对象类型的强制转换
- instanceof运算符
- 强制类型转换

### Object类
- Object类概述
- clone()方法
- equals()方法
- toString()方法
- getClass()方法