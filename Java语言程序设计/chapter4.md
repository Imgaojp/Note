# Java面向对象特性
## 概述
### Java的OOP特性
- 封装（encapsulation）


将对象的数据与操作数据的方法相结合，通过方法将对象的数据与实现细节保护起来，就称为封装。外界只能通过对象的方法访问对象，因此封装同时也实现了对象的数据隐藏。<br>
Java语言中，通过类这样的语言机制实现了数据的封装与隐藏。
- 继承（inheritance）

当一个类是另一个类的特例时，这两个类之间有父子类关系。子类继承了父类的状态（变量）和行为（方法），子类可以重复使用父类中的这部分代码。<br>
Java中只支持类之间的单继承，多重继承要通过接口实现。
- 多态（polymorphism）


多态的含义可以表达为“对外一个接口，内部多种实现”。Java语言支持两种形式的多态：运行时多态和编译时多态。通过方法的重载（overloading）实现编译时多态，而通过类之间的继承性。方法重写以及晚联编技术实现运行时多态。<br>
多态使程序具有良好的可拓展性，并使程序易于编写维护、易于理解。

###Java中类和对象基本概念
类和对象是Java程序的基本组成要素。类描述了同一类对象都具有的数据和行为。Java语言中的类将这些数据和行为进行封装，形成了一种复合数据类型。创建一个新类就是创建了一种新的数据类型。在程序中类只定义一次，而用new运算符可以实例化用一个类的一个或多个对象。类定义和描述了一类对象的共同特征。
##类的定义
###类的基本结构
类有两种基本成分：变量和方法，称为成员变量和成员方法。类的成员变量可以使基本类型的数据或数组，也可以是一个类的实例。类的方法用于处理该类的数据。方法与其他语言中的函数的区别在于：(1)方法只能是类的成员，只能在类中定义。(2)调用一个类的成员方法，实际上是进行对象之间或用户与对象之间的消息传递。
Java类定义的基本语法：
```Java
<modifiers>class<class_name>{
	[<attribute_declarations>]
	[<constructor_declarations>]
	[<methods_declarations>]
}
```
Java类的定义可以分为两部分：类声明和类体。类体部分包括类成员变量的声明、构造方法和成员方法的声明与定义。
- 类的声明

类定义中的类声明部分主要是声明了该类的名字以及类的其它属性。
```
[public][abstarct|final]class ClassName[extends SuperClassName][implements InterfaceNameList]{...}
```
- 类体

出现在类声明后的大括号`{}`中的是类体。类体提供了这个类的对象在生命周期中需要的所有代码：构造和初始化新对象的构造方法，表示类及其对象状态的变量，实现类及其对象行为的方法，并且在极少数的情况下还可以有用来进行对象清除的finalize()方法。
- 类的封装与信息隐藏

Java中通过类实现封装与信息隐藏。具体是通过对类成员限定访问权限实现的。Java中用于类成员的访问权限有4种，分别用3中权限定义符——public,protected,private以及默认权限来定义。封装的同时最大限度的隐藏了对象内部细节，使得对象在于外界交互提供服务的同时，能够保证自身数据的完整性与一致性。

### 成员变量
当一个变量的声明出现在类体中并不属于任何一个方法，则该变量为所属类的成员变量。类成员变量的基本声明和一般变量声明一样，必须包括类型与变量名，但增加了许多可选的修饰选项。成员变量完整的声明格式如下：
```
[public|protected|private][static][final][transient][volatile] type varibleName;
```
public、protected、private|该对象成员变量的访问权限
---|---
static|限制该成员变量为类变量，没有static修饰的成员变量为实例变量
final|声明一个常量，final修饰的常量，程序中不能修改它的值，且命名应该用由下划线分开的大写的词表示
transient|用来声明一个暂时性变量。默认情况下，类中所有变量都是对象永久状态的一部分，当对象被保存到外存时，这些变量必须同时被保存。用transient限定的变量则指示JVM该变量不属于对象的永久状态，从而不能被永久存储。
volatile|volatile修饰的变量，在被多个并发线程共享时，系统将采取更优化的控制方法提高线程并发执行的效率。
### 成员方法
- 成员方法的定义
	- 方法的声明完整格式如下：
	```
	[<acesslevel>][static][final|abstract][native][synchronized]<return_type><name>([<argument_list>])[throws <exception_list>]{
		<block>
	}
	```
	- 方法体
	
	方法体是对方法的实现。它包括局部变量的声明以及所有合法的Java语句。
	方法体中可以声明该方法中所用到的局部变量，它的作用域只在该方法内部，当方法返回时，局部变量也不再存在。如果局部变量名字和类成员变量的名字相同，则类的成员被隐藏，如果要将该类成员变量显露出来，则需在该变量前加上修饰符"this"。
- 方法调用中的参数传递方式

Java中方法调用的参数传递是传值，即调用方法不会改变调用程序中作为方法参数的变量的值。但是当方法的参数类型是对象或者数组等引用类型时，在方法调用中传递给该参数的仍然是调用程序中对应变量的值，即对某个对象或者数组的引用。但如果在方法中对该参数指向的对象进行修改，则这种修改将是永久的，即当从方法中退出时，对象的修改将被保留下来，在调用程序中可以看到这种改变。因此，在方法中可能改变引用类型所指向的对象的内容，但是对象的引用不会改变。
- 可变参数列表*Varargs*

使用可变参数表，可以使方法具有数目不定的多个参数。可变参数的定义格式一般为：
```Java
int...nums	//类型...参数名
```
使用可变参数列表需要注意一下问题：

1. 可变参数只能作为方法参数列表中的最后一个参数
2. 如果要调用的API中具有可变参数列表的方法，则尽量使用，使程序易读。如果要编写API则尽量少用，只在好处明显时使用。一般情况下，不要重载带有可变参数列表的方法，否则会使其他人很难确定具体被调用的重载方法。

### 方法重载
Java语言提供了方法重载（overloading）机制。方法的重载是允许在一个类的定义中，多个方法使用相同的方法名。
```Java
public void println(int i){...}
public void println(float f){...}
public void println(String str){...}
```
重载是指在同一个类中一个方法名被用来定义多个方法。方法重载是面向对象语言多态性的一种形式，它实现了编译时多态。即由编译器在编译时确定具体调用哪个被重载的方法。<br>
重载方法的名称都是相同的，但是在方法的声明中一定要有彼此不相同的成分，以使编译器能够区分这些方法。因此Java中规定重载的方法必须遵循以下原则：
- 方法的参数表必须不相同，包括参数的类型或个数，以此区分不同方法体。
- 方法返回类型、修饰符可以相同也可不同。

### this
this是Java使用的一个具有特定意义的引用，它指向当前对象本身。
### 构造方法
Java中所有的类都有构造方法，用来进行该类对象的初始化。构造方法也有名称、参数和方法体以及访问权限的限制。
- 构造方法的定义格式


```Java
[public|protected|private]<class_name>([<argument_list>]){
	[<statements>]
}
```


构造方法的定义十分特殊，其特点如下：

1. 构造方法的名称必须与类名相同。
2. 构造方法不能有返回值。
3. 用户不能直接调用构造方法，必须通过*new*关键字自动调用它。


- 默认的构造方法

在类的定义中可以不定义构造方法，而其他类仍然可以通过*new XXX()*来实例化*XXX*类的实例对象。因为Java在编译时给没有定义构造方法的类自动加入一个特殊的构造方法，这个方法不带参数且方法体为空，称之为类默认的构造方法。<br>
**注意：一旦在类中定义了构造方法，则默认的构造方法将不再被加到类的定义中。此时，如果程序中使用默认的构造方法将出现编译错误。为了避免此类错误，如果类中定义了构造方法，通常也将加入不带参数的构造方法。**
- 重载构造方法


构造方法可以重载，即定义多个构造方法，其参数表不同。重载构造方法的目的是使类对象具有不同的初始值，为类对象的初始化提供方便。

### 访问控制
- 访问控制概述

Java中，可以在类的定义中使用权限修饰符来保护类的变量和方法。Java支持如下四种不同的访问权限。

1. 私有的——以private修饰符指定：没有其他类可以实例化该类。此时这个类中可能包含一个具有public权限的方法（factory方法），只有这些方法可以构造该类的对象并将其返回。
2. 受保护的——以protected修饰符指定：只有这个类的子类以及与该类在同一个包中的类可以创建这个类的实例对象。
3. 公开的——以public修饰符指定：任何类都可以创建这个类的实例对象。
4. 默认的，也称为default或package——不适用任何修饰符：只有与该类在同一个包中的类可以创建这个类的实例对象。


对于类的成员变量和方法可以定义上述4种访问级别：public，protected，default，private，对于类（内部类）可以有public或default两种。
- private

类中带有*private*的成员只能被这个类自身访问。*private*对访问权限限制最大。一般把那些不想让外界访问的数据和方法声明为私有的，这有利于数据的安全并保证数据的一致性，也符合程序设计中隐藏内部信息处理细节的原则。<br>
对于构造方法也可以限定它为*private*。如果一个类的构造方法声明为*private*，则其它类不能生成该类的实例对象。<br>
**注意：同一个类的不同对象之间可以访问对方的*private*成员变量和方法。因为访问控制是在类的级别上的，不是在对象的级别上。**


```Java
class Alpha{
	private int iamprivate;
	public Alpha(int i){
		this.iamprivate = i;
	}
	boolean isEqualTo(Alpha anotherAlpha){
		if(this.iamprivate == anotherAlpha.iamprivate)	//访问另一个Alpha对象的私有变量
			return true;
		else
			return false;
	}
}
public class Test{
	public static void main(String args[]){
		Alpha aa = new Alpha(10);
		Alpha bb = new Alpha(22);
		if(aa.isEqualTo(bb)){	//aa可以访问另一个类的私有对象，再与自身私有变量进行对比
			System.out.println("equal");
		}else
			System.out.println("not equal");
	}
}
```
- default

不加任何访问权限限定的成员采用的默认访问权限，称为default或者package。default权限意味着可以被这个类本身和同一个包中的类访问。在其他包中定义的类，即使是这个类的子类，也不能直接访问这些成员。对于构造方法，如果不加任何访问权限也是default访问权限，则除这个类本身和同一个包中的类之外，其他类不能生成该类的实例。
- protected

类的定义中带有protected的成员可以被这个类本身、它的子类（与该类在同一个包或者不在）以及同一个包中的其它所有类访问。当同一个包中的类或子类都可以访问类的成员，而无关的类不能访问这些成员时，可将他们的访问权限设定为protected。
- public

public是最简单的访问控制修饰符。带有public的成员可以被所有的类访问，任何包中的任何类都可以直接访问public变量和方法。对于构造方法，如果访问权限限定为public，则在所有类中都可以生成该类的实例。<br>
一般把外界需要直接访问的类成员，很多情况下是方法，说明为public访问权限，用来作为外界与类交换信息的接口。

## 内部类
### 什么是内部类
内部类是在一个类的声明里声明的类，也成为嵌套类。内部类和包容它的类可以形成有机的整体。
```Java
class A{
	...
	class B{...}
	...
}
```
类B在类A中定义，所以B称为内部类，类A称为B的包容类或者外包类。
### 内部类的使用
- 内部类作为外包类的一个成员使用

内部类可以作为外包类的一个成员使用，可以访问外包类的所有成员，包括带有static的静态成员变量和方法，以及private私有成员。<br>
JVM在内部类实现中，在内部类对象中保存了一个对其外包类对象的引用。内部类可以通过该引用找到外包类的对象，进而访问外包类的成员，采用的格式是：外包类名.this.变量名。
- 在外包类的语句块中定义内部类

内部类可以在一个方法体的语句块中定义。这时内部类可以访问语句块中的局部变量，但只限于在该语句块运行期内，当该方法结束后，内部类对象将不能访问所在语句块中的局部变量。但因为final变量在方法运行结束后仍然存在，所以内部类对带有final的局部变量的访问不受限制。


另外，这样的内部类只能用于在定义它的语句块中创建内部类的对象，而且内部类的类名也不能出现在定义它的语句块之外。

- 在外包类以外的其他类中访问内部类

Java中，内部类的访问权限与普通类和接口不同，可以定义为public，protected，default或private，而普通类只能定义为public或者default两种。对于可以在外包类之外访问的内部类，引用内部类名时必须使用完整的标识：外包类名.内部类名，并且在创建内部类对象时，必须与外部类的对象相关。例如，类B是类A的内部类，则在其他类中要以下列格式访问类B：
```
A a = new A();
A.B b = a.new B();
```

### 内部类的特性
+ 内部类的类名只用于定义它的类或语句块之内，在外部引用它时必须给出带有外包类名的完整名称，并且内部类的名字不许与外包类的名字相同。
+ 内部类可以访问外包类的静态（static）或实例成员变量。
+ 内部类可以在成员方法中定义，该成员方法的局部变量及参数必须是final的才能被该内部类使用。
+ 内部类可以是抽象类或者接口。如果是接口，则可以由其它内部类实现。
+ 内部类可以使用public，protected，default，private这4种访问权限控制。
+ 内部类可以被声明为static（普通类是不可以的），这样内部类变成顶层类，相当于把它放在外面，不再是嵌套的内部类，并且它的对象中将不包含指向外包类对象的指针，所以不能再引用外包类对象。
+ 只有顶层类可以声明static成员。如果内部类需要定义static成员，则该内部类必须声明为static，否则，一般内部类的成员不能被声明为static。

## 对象的生命周期
对象的声明周期包括了对象的创建、对象的使用和对象回收3个阶段。
### 对象的创建
- 对象创建的步骤<br>
类是对象的模板，Java依据一个类创建一个对象。创建一个对象包括两个步骤：
	- 声明对象变量<br>
	以SomeClass objectVar的形式声明保存该对象引用的变量，将来可以通过该变量对对象进行操作。对象变量的声明并没有创建对象，系统只为其分配一个引用空间。
	- 对象的实例化<br>
	通过使用new运算符进行对象的实例化：new SomeClass()。对象实例化的过程是：为对象分配空间，执行new运算符后的构造方法完成对象的初始化，并返回该对象的引用。

- 创建与初始化对象的过程<br>
系统执行new SomeClass()将执行构造与初始化对象的操作，创建一个新的对象。其过程如下：
	- 首先为对象分配内存空间，并将成员变量进行初始化。数值型变量的初始值为0，逻辑型为false，引用型为null。
	- 然后执行显式初始化，即执行在类成员声明时带有的简单赋值表达式。
	- 执行构造方法，进行对象的初始化。

### 对象的使用
对象在被创建后，就可以对对象进行访问。用过圆点运算符可以访问对象的状态和对象的方法。
- 引用对象的变量<br>
引用对象变量的一般格式如下：
```Java
objectReference.variableName
```
**注意：对对象变量的直接操作是不提倡的，因为有可能设置无意义的变量值。可以通过对象提供的setter和getter方法进行写和读。**
- 调用对象的方法<br>
对象方法的调用格式如下：
```Java
objectReference.methodName(argumentList);
```
对象的方法也可以通过设置访问权限来允许或禁止其它对象对它的访问。
### 对象的清除
- 垃圾收集器<br>
Java运行系统中的垃圾收集器周期性的释放不再被引用的对象所占有的内存，自动执行内存回收。但垃圾收集器却以较低优先级在系统空闲周期中执行，因此垃圾的收集速度比较慢。某些情况下，可以通过System类的gc()方法显式的执行垃圾收集。
- 对象的最终化（finalization）处理<br>
一个对象在被收集之前，垃圾收集器将调用对象的finalize()方法，以使对象自己能够做到最后的清理，释放占有的资源，这个过程称为对象的最终化。只有进行最终化处理的对象才意味着被废弃。

## 类的继承与多态
### 类的继承
- 子类及其定义<br>
类之间的继承关系是面向对象程序设计语言（OOP）的基本特征之一。继承是类之间的"is a"关系，反映出一个类（子类）是另一个类（父类）的特例。在OOP中，继承反映了现实世界实体的这种本质联系，而另一个重要意义是实现了代码的重用。<br>
子类可以继承父类的属性和方法，子类中只需要声明自己特有的东西。但要注意子类并不能继承父类的所有变量和方法，下列是子类不能继承的：
	- 带private修饰符的属性、方法是不能被继承的
	- 构造方法不能被继承<br>

子类继承父类的变量和方法，同时也可以修改父类的变量或方法，并增加新的变量或方法，从而可以构造多种比父类更加特殊、具体的类。
- 单继承<br>
Java不支持多重继承，只支持单继承，即只能从一个类继承，extends关键字后的类名只能有一个。单继承的优点是可以避免多个直接父类之间可能产生的冲突，使代码更可靠。在Java中，一组类之间的继承关系可以形成一个树型的层次结构图。<br>
多重继承在现实世界中是普遍存在的，Java提供了接口（interface）机制，允许一个类实现多个接口。这样避免了多重继承的复杂性，又达到了多重继承的效果。Java通过接口实现多重继承。
- super关键字<br>
super关键字指向该类所在类的父类，用来引用父类中的成员变量或方法。通过*super.someMethod([paramlist])*将调用父类中的*someMethod()*方法。该方法不一定是在当前类的父类中定义的，但可以是直接父类在类的层次体系中继承而来。
- 子类对象的创建与实例化过程<br>
Java中对象的初始化是很结构化的，目的是保证程序运行的安全性。在有继承关系的类的体系中，一个子类对象的创建与初始化经过以下3部：
	- 分配对象所需要的全部内存空间，并初始化为0
	- 按继承关系，自顶向下显式初始化
	- 按继承关系，自顶向下调用构造方法

Java的安全模型要求对象在初始化时，必须先将父类继承的部分进行完全的初始化。因此Java在执行子类构造方法之前通常要调用父类的一个构造方法。一般在子类构造方法的第一行通过*super([paramlist])*调用父类的构造方法，如果不用super关键字指定，则Java将调用父类默认的构造方法（不带参数的构造方法）。如果父类没有无参数的构造方法将产生错误。

### 方法的重写
- 子类中父类成员的隐藏<br>
在类层次结构中，当子类的成员变量与父类的成员变量同名时，子类的成员变量会隐藏父类的成员变量；当子类的方法与父类具有相同的名字、参数列表、返回值类型时，子类的方法重写了父类的方法，在父类定义的方法就被隐藏。“隐藏”的含义是，通过子类对象调用子类中与父类同名的变量和方法时，操作的是这些变量和方法在子类中的定义。子类通过成员变量的隐藏和方法的重写可以把父类的状态和行为改变为自身的状态和行为。
- 方法重写<br>
重写（overriding）是指子类重写父类的成员方法。子类可以改写父类方法所实现的功能，但子类中重写的方法必须与父类中的对应的方法具有相同的返回值、参数列表和方法名。
- 方法重写遵守的规则<br>
方法重写是实现对象运行时多态的基础。以下规则对于保证多态中对外统一接口的一致性是非常重要的。Java中方法重写要遵守以下规则：
	- 子类中重写方法的返回值类型必须与父类中被重写方法的返回值类型相同。
	- 子类中重写方法的访问权限不能缩小。（父类中被重写的方法的访问权限如果是public，子类在重写该方法时，不能将其访问权限改为protected，private或者default）
	- 子类中重写方法不能抛出新的异常。

### 运行时多态
- 上溯造型（upcasting）<br>
类之间的继承关系使子类具有父类的所有变量和方法，这意味着父类所具有的方法也可以在它所派生的各级子类中使用，发给父类的任何消息也可以发送给子类。所以子类的对象也是父类的对象，即子类对象既可以作为该子类的类型也可以作为其父类类型对待。因此，从一个基础父类派生的各种子类都可以作为同一种类型——基础父类的类型对待。将一种类型（子类）对象的引用转换成另一种类型（父类）对象引用，就称为上溯造型。<br>
上溯造型是从一个特殊、具体的类型到一个通用、抽象类型的转换，肯定是安全的。Java有一个类*java.lang.Object*，它是所有类的父类。因此当一个数组的类型为Object时，该数组将可以包含任何类型的对象。

- 什么时候运行时多态<br>
Java中上溯造型的自然存在，是一个对象既可以当作它自己的类型也可以作为其父类的类型对待，这意味着子类对象可以作为父类的对象使用；父类的对象变量可以指向子类对象。这样通过一个父类变量发出的方法调用，可能执行的是该方法在父类中的实现，也可能是在某个子类的实现，这只能在运行时刻根据该变量指向的具体对象类型确定，这就是运行时多态。<br>
同一个父类派生出的多个子类可以被当作同一种类型对待，相同的一段代码就可以处理所有不用的类型。多态性的使用使代码的组织以及可读性均能够得到改善，另外还使程序具有很强的可拓展性。

- 运行时多态的实现机理<br>
运行时多态的实现机理是动态联编技术，也叫作晚联编或运行期联编。将一个方法调用和一个方法体连接到一起就称为联编（binding）。若程序运行之前执行联编操作，则称为“早联编”；在运行时执行联编就称为“晚联编”。<br>
在晚联编中，联编操作是在程序的运行期间判断对象的类型，并进一步调用适当的方法。也就是说，在晚联编中编译器此时仍然不知道对象的类型，但运行时刻的方法调用机制能够自己确定并找到正确的方法体。<br>
Java中，除了定义为final的方法，其余所有方法的联编都采用晚联编技术。当方法被声明为final时，一方面可以防止子类中对该方法的重写，另一方面，也可以有效地阻止晚联编，即通知编译器不需要动态联编，使编译器为final方法调用生成运行效率更高的代码。
- 多态的意义<br>
Java的多态性，突出的优点是使程序具有良好的可拓展性。当程序从通用的基础类派生任意多的新类型，或向基础类增加更多方法时，无须修改原有对基础类进行处理的相关程序。并且可以处理这些新的类型，为程序增加新的功能。如果这些程序是在一个独立的文件中，则不需要重新编译。<br>
为了利用多态使程序具有良好的可拓展性，程序中的方法要尽量利用基础类的接口。

### 对象类型的强制转换
对象的强制类型转换也称为向下造型*(downcasting)*或者造型*(casting)*，是将父类类型的对象强制（显式）地转换为子类型。Java中允许上溯造型的存在，使得父类类型的变量可以指向子类对象，但通过该变量只能访问父类中定义的变量和方法，子类特有的部分被隐藏，不能访问。只有将父类类型变量强制转换为具体的子类类型，才能通过该变量访问子类的特有成员。
<br>对象强制类型转换中，一般先要测试确定对象的类型，然后执行转换。
- instanceof运算符
<br>在Java中使用instanceof测试对象的类型。由该运算符构造的表达式的一般形式如下：
```Java
aObjectVariable instanceof SomeClass
```
- 强制类型转换
<br>强制类型转换的格式如下：
```Java
(SomeClass)aObjectVariable
```
在进行对象类型的强制转换时，为了保证转换能够成功进行，一般先使用instanceof对对象的类型进行测试，当测试结果为true再进行转换。
<br>Java语言在执行强制类型转换时遵循以下规则：
	- 对象变量转换的目标类型，一定要是当前对象类型的子类。这个规则由编译器进行检查。
	- 在运行时刻也要进行对象类型的检查。例如某个进行对象类型转换的程序中，省略了instanceof测试，并且对象的类型并不是其要转换的目标类型，那么程序运行中将抛出异常。


### Object类
- Object类概述
<br>Object类是Java平台中类层次树的根。Java中的每个类都是Object类的直接或者间接子类。由于这种特殊地位，这个类中定义了所有对象都需要的状态和行为，如对象之间的比较、将对象转换为字符串、等待某个条件变量、当某条件变量改变时通知相关对象以及返回对象的类等。
<br>在Object子类中可以重写以下方法：
	- *clone()*
	- *equals()/hashCode()*：这两个方法必须同时重写
	- *finalize()*
	- *toString()*：返回对象的字符串表示，表达的内容因具体的对象而异<br>
以下方法不能被重写，因为它们都被定义为final:
		- *getClass()*
		- *notify()*
		- *notifyAll()*
		- *wait()*


- clone()方法<br>
利用Object方法可以将一个已有对象复制为另一个对象。利用下列语句实现对象的复制:
```Java
aCloneableObject.clone();
```
上述方法将创建一个与*aCloneableObject*相同类型的对象，并把该对象成员变量的值初始化为*aCloneableObject*中相应成员变量的值。<br>
需要注意下列问题：
	- 被调用*clone()*方法的对象*aCloneableObject*必须实现了*java.lang.Cloneable*接口，否则运行时将抛出*CloneNotSupportedException*异常。因为*Object*类本身并没有实现这个接口，所以提供复制能力的类必须自己实现*Cloneable*接口。
	- *clone()*方法是*shallow copy*而不是*deep copy*。*shallow copy*——浅复制：指如果被复制对象的成员变量是一个引用类型变量(如是一个对象数组)，则复制对象中将不包括该变量指向的对象。*deep copy*——深复制：在上述情况下，将同时复制该变量指向的对象。
- equals()方法<br>
Object类的*public boolean equals(object obj)*方法，比较当前对象的引用是否与参数obj指向同一个对象。但String,Data,File类和所有包装类（Wrapper class，如Integer，Long等）都重写该方法，改为比较所指对象的内容。另外Java中的恒等运算符"=="对于引用型变量，比较的是两个变量所指对象的地址。
- toString()方法<br>
toString()方法返回对象的字符串表示，表达的内容因具体对象而异。该方法在调试时对确定对象的内部状态是很有价值的，为此一般在自己的类中重写该方法。例如：
```Java
System.out.println(Thread.currentThread().toString());
```
- getClass()方法<br>
*getClass()*方法返回对象的类信息，该方法返回一个Class类型的对象。例如，下面的方法将获取对象的类名并显示：
```Java
void getClassName(Object obj){
	System.out.println("The name of the object is" + obj.getClass().getName());
}
```
Class类型常用于在运行时刻创建在编译时不知道类型的对象。