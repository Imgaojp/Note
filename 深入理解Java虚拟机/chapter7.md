# 虚拟机类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。在Java语言里，类型的加载、连接和初始化都是在程序运行期间完成的，虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供了高度的灵活性，Java天生可以动态拓展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

## 类加载的时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution），初始化（Initialization）、使用（Using）、卸载（UNloading）7个阶段。验证、准备、解析3个部分统称为连接（Linking）。

加载、验证、准备、初始化和卸载这5个阶段顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后开始，这是为了实现Java运行时绑定（动态绑定或晚期绑定）。前面提及的5个阶段通常都是交叉的混合式进行，但是开始是按照顺序，一个阶段执行过程中调用、激活另一个阶段。

必须对类进行初始化的5种情况（而加载、验证、准备自然在此之前）：
- 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发使其初始化。生成这4条指令最常见的Java代码场景：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的字段除外）、调用一个类的静态方法等时。
- 使用java.lang.reflect包的方法对类进行反射调用时。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则先触发父类的初始化。
- 虚拟机启动时，包含main（）方法的类。
- 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有初始化时。

## 类加载的过程

### 加载
“加载”是“类加载”（Class Loading）过程的一个阶段。在加载过程中，虚拟机完成以下任务：
- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口

获取一个类的二进制字节流可以通过诸多手段：
1. 从ZIP包读取，成为JAR、EAR、WAR格式的基础
2. 从网络中获取，典型应用是Applet
3. 运行时计算机生成，比如动态代理技术，在java.lang.reflect.Proxy中就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“$Proxy”的代理类的二进制字节流
4. 从其他文件生成，比如JSP文件生成对应的Class类
5. 从数据库中读取

