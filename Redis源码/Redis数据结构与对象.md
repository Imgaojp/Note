#Redis数据结构与对象

Redis数据库里面的每个键值对都是由对象组成的，其中：

- 数据库的键总是一个字符串对象
- 数据库键的值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象五种对象中的一种。

而这五种对象的底层是基于简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表实现的，接下来介绍这些数据结构。
## 简单动态字符串
Redis自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为Redis的默认字符串表示。C传统字符串只在作为字符串字面量，无须对字符串值进行修改的地方，比如打印日志。而Redis需要一个可以被修改的字符串值时，会使用SDS来表示。
###SDS的定义
SDS的结构定义在sds.h/sdshdr中：

```
struct sdshdr{
	//记录buf数组中已使用字节的数量，等于SDS保存字符串的长度
	int len;
	//记录buf数组中未使用字节的数量
	int free;
	//字节数组，保存字符串
	char buf[];
	};
```
SDS遵循C字符串以空字符结尾的惯例，在结尾保存了空字符 '\0'，保存空字符的1字节空间不计算在len属性里面，并为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作都是SDS函数自动完成的。遵循空字符结尾的好处是：SDS可以直接重用一部分C标准库里面的函数，比如printf。
###SDS与C字符串区别

1. SDS获取字符串长度的时间复杂度是O(1)，直接访问SDS的len属性就可以，设置和更新len属性的工作由SDS的API自动完成的；而C字符串需要遍历字符串计数为O(N)

2. C字符串不记录长度带来的另一个问题是缓冲区溢出[^1]；SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS的API对SDS进行修改时，API会首先检查SDS的空间是否满足修改所需的要求，如果不满足，API会自动将SDS的空间扩展至执行修改所需的大小，然后再执行实际的修改从操作，所以使用SDS不需要手动修改SDS空间大小，也不会出现缓冲区溢出。

3. SDS可以减少修改字符串时带来的内存重分配次数。而C字符串则每次增长或者缩短一个C字符串都要对这个C字符串的数组进行内存重分配操作：如果执行增长字符串的操作，要通过内存重分配来扩展底层数组空间大小（如果忘了就会缓冲区溢出）；如果执行缩短字符串的操作，要通过内存重分配来释放字符串不再使用的内存（如果忘了就会内存泄露）。

	 **内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以是比较耗时的操作：**
 1. 一般程序中，修改字符串长度情况不太出现，每次修改都执行一次内存重分配是可以接受的
 2. 但是Redis作为数据，经常被用于速度要求严苛、数据频繁修改的场合，如果每次修改字符串长度都需要执行一次内存重分配会导致修改字符串耗时较多，可能会对性能造成影响。 

	通过未使用空间（buf数组free的部分），SDS实现了**空间预分配**和**惰性空间释放**两种优化策略。
	1. 空间预分配：当SDS的API对一个SDS进行修改，并需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间。通过预分配策略，SDS将连续增长N次字符串所需的内存分配次数从必定N次降低为最多N次。
		- 在扩展SDS空间之前，SDS API会先检查未使用空间是否足够，如果足够直接视同未使用空间，否则内存重分配。
		- 如果对SDS进行修改后，SDS的长度将小于1MB，那么程序分配和len属性同样大小的未使用空间，这是SDS的len将和free的值相同
		- 如果SDS的长度将大于1MB，那么程序会分配1MB的未使用空间。
	2. 惰性空间释放：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录下来，并等待将来使用。同时SDS提供了相应地API真正的释放SDS的未使用空间，所以不用担心内存浪费。


4. 二进制安全
C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾外，字符串里面不能包含空字符，否则最先被读入的空字符将被误认为是字符串结尾，因此C字符串只能保存文本数据，不能保存像图片、音频、视频等二进制数据。而SDS的API是二进制安全的，所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，因此buf数组被称为字节数组，可以保存任意格式的二进制数据。
5. 兼容部分C字符串函数
虽然SDS的API是二进制安全的，但它们一样遵循C字符串以空字符串结尾的惯例：这些写API会将SDS保存的数据的末尾设置为空字符，并且总会为buf数组分配空间时多分配一个字节容纳空字符，这是为了让那些保存文本数据的SDS可以重用一部分`<string.h>`库定义的函数。
6. 总结
 C字符串 								|     SDS
:---------|:-----
获取字符串长度时间复杂度O(N)			|获取字符串长度时间复杂度O(1)
API是不安全的，可能会造成缓冲区溢出		|API是安全的，不会造成缓冲区溢出
修改字符串长度N次必然需要执行N次内存重分配	|修改字符串长度N次最多需要执行N次内存重分配
只能保存文本数据						|可以保存文本或二进制数据
可以使用所有`<string.h>`库中的函数		|可以使用一部分`<string.h>`库中的函数

###SDS API

函数|作用|时间复杂度
---|--|--
sdsnew|创建一个包含给定C字符串的SDS|O(N)，N为给定C字符串的长度
sdsempty|创建一个不包含任何内容的空SDS|O(1)
sdsfree|释放给定的SDS|O(N)，N为被释放的SDS的长度
sdslen|返回SDS的已使用空间字节数|这个值可以通过读取SDS的len属性直接获得，O(1)
sdsavail|返回SDS的未使用空间字节数|这个值可以通过读取SDS的free属性直接获得，O(1)
sdsdup|创建一个给定SDS的副本|O(N)，N为给定SDS的长度
sdsclear|清空SDS保存的字符串内容|因为惰性空间释放策略，复杂度为O(1)
sdscat|将给定C字符串拼接到SDS字符串的末尾|O(N)，N为被拼接C字符串的长度
sdscatsds|将给定SDS字符串拼接到另一个SDS字符串末尾|O(N)，N为被拼接SDS字符串的长度
sdscpy|将给定的C字符串复制到SDS里面，覆盖SDS原有的字符串|O(N)，N为被复制C字符串的长度
sdsgrowzero|用空字符将SDS扩展至给定长度|O(N)，N为扩展新增的字节数
sdsrange|保留SDS给定区间内的数据，不在区间的数据会被覆盖或清除|O(N)，N为被保留的字节数
sdstrim|接受一个SDS和一个C字符串作为参数，从SDS左右两端分别移除所有在C字符串中出现过的字符|O(M*N)，M为SDS的长度，N为给定C字符串的长度
sdscmp|对比两个SDS字符串是否相同|O(N)，N为两个SDS中较短的那个SDS的长度


[^1]:缓冲区溢出